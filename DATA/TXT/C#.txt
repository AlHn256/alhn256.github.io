ASP.NET. - технология для выполнения всего, начиная от построения приложений Windows и заканчивая выполнением запросов в базах данных, и специально ориентированный на разработку веб-сайтов. Сегодня ASP.NET пользуется небывалой популярностью, но особо революционной технологией уже больше не является. И хотя базовые функциональные возможности, лежащие в основе ASP.NET, на удивление, выглядят точно так же, как и десять лет назад, разработчики из Microsoft добавили к ним еще кое-какие дополнительные средства и абстракции кодирования более высокого уровня.

NET Framework - старая платформа, работающая только под Windows.

NET Core - новая платформа, которая может работать как под Windows, так и под Linux. Но она еще довольно "сырая" - множество инструментов еще не перенесены на нее.
	Подключить одно к другому не получится, потому что у них разные системные библиотеки (а также разные системы сборки если вы используете Visual Studio версии 2015 или ниже).

Аспектно-ориентированное програмирование - базируется на изучении того сколько и каких компонент или частей требуется для взаимодействия с системой. Основным для АОП является взаимодействие этих элементов.

Интерфейсно-ориентированное программирование - подход основанный на программировании по контракту. Ни одна часть интерфейса не зависит от того как реализована другая, вся коммуникация между ними описана в контракте. Веб-сервисы на основе WSDL наиболее известный пример этого подхода.

Объектно-ориентированное программирование - основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построение объектов, контролирующих или реализующих систему. Это такой подход к написанию программ, который основывается на объектах, а не на функциях и процедурах. Эта модель ставит в центр внимания объекты, а не действия, данные, а не логику. Объект - реализация класса. Все реализации одного класса похожи друг на друга, но могут иметь разные параметры и значения. Объекты могут задействовать методы, специфичные для них. ООП сильно упрощает процесс организации и создания структуры программы. Отдельные объекты, которые можно менять без воздействия на остальные части программы, упрощают также и внесение в программу изменений. Так как с течением времени программы становятся всё более крупными, а их поддержка всё более тяжёлой, эти два аспекта ООП становятся всё более актуальными.

Абстракция - для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счёте — контекстное понимание предмета, формализуемое в виде класса

Полиморфизм - позволяет одному и тому же интерфейсу работать с данными разных типов, обозначает способность языка трактовать связанные объекты в сходной манере, также позволяет базовому классу определять набор методов (формально называемый полиморфным интерфейсом), которые доступны всем наследникам. Полиморфный интерфейс класса конструируется с использованием любого количества виртуальных или абстрактных членов. реализуется принцип полиморфизма в С++ С помощью виртуальных методов. В более общем смысле понятие полиморфизма нередко выражается следующим образом: "один интерфейс - множество методов". Это означает, что для группы взаимосвязанных действий можно разработать общий интерфейс. Полиморфизм помогает упростить программу, позволяя использовать один и тот же интерфейс для описания общего класса действий. Выбрать конкретное действие (т.е. метод) в каждом отдельном случае - это задача компилятора. Программисту не нужно делать это самому. Ему достаточно запомнить и правильно использовать общий интерфейс. За самым садистским определением кроется возможность языка программирования для декомпозиции задачи и рефакторинга if'ов и switch'ей.
	Статический полиморфизм - адрес метода который вызывается определяется при компиляции. (пример - обработка шаблонами разных типов)
	Динамический полиморфизм - адрес метода который вызывается определяется в рантайме (из VMT объекта чей метод вызывается). Пример - есть действительно рыбки птички и т.п. Запихнули элементы всех в один массив Animal Animals[]. Вызываем для каждого элемента массива Animals виртуальный метод Move, и каждый элемент плывет, летит скачет по своему.
	Параметрический полиморфизм - Пример - у каждого Animal есть поле в котором помечено кто он и куча методов которые реализуют поведение. в методе Move класса Animal примерно вот такой код:
	Animal::Move(){
		switch (AnimalType){
			case atFish: FishMove();
			break; 
			case atBird: BirdMove() 
			break;
			case atHuman: HumanMove(); 
			break; 
		}  
	}

Инкапсуляция - механизм языка, позволяющий объединить данные и методы в единый объект и скрыть детали реализации от пользователя

Уровени доступа (Модификаторы доступа) - позволяют задать допустимую область видимости для членов класса.
    public - Доступ не ограничен
    protected - Доступ возможен из этого класса и из классов, унаследованных от него
    internal - Доступ ограничен только текущей сборкой (.exe, .dll и т. д.)
    protected internal - Доступ ограничен содержащим классом, классами, которые являются производными от содержащего класса, либо классами в той же сборке
    private - Доступ возможен только из этого класса
    private protected - Доступ ограничен содержащим классом или классами, которые являются производными от содержащего типа в той же сборке
	sealed - запрещает другим классам наследоваться от этого класса
	
Наследование (inheritance) - Благодаря наследованию один класс может унаследовать функциональность другого класса

Виртуальные методы и свойства - При наследовании нередко возникает необходимость изменить в классе-наследнике функционал метода, который был унаследован от базового класса. В этом случае класс-наследник может переопределять методы и свойства базового класса. Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными. А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override. Переопределенный метод в класе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.

Extension - позволяет без изменения исходного кода и создания наследников расширять классы новыми методами.
	Синтаксис записи такого метода:
	public static int MyMethod(this string str)
	{
	int count = 0;
	return count;
	}

Перегрузка - Язык программирования C# позволяет осуществлять перегрузку методов в классе. Фактически, перегружается имя метода. Все перегруженные методы носят одинаковое имя. Перегруженные методы отличаются параметрами. Точнее говоря, тип параметров или количество параметров в перегруженных методах должны отличаться.

Объект\класс - Описанием объекта является класс, а объект представляет экземпляр этого класса

Класс - структурированный блок кода, написанный определенным образом, чтобы обозначить набор или целую категорию вещей. Люди используют классы, чтобы создавать больше вещей. Они создают новые классы, присваивают им значения и используют методы (также известные как функции) для работы с экземплярами класса

Классы и объекты - являются основным типом в языке C#. Класс предоставляет определение для динамически создаваемых экземпляров класса, которые также именуются объектами. 
	Классы поддерживают механизмы наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов. По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова сlass:
	Конструктор - это метод, имя которого совпадает с именем его типа. Его сигнатура метода содержит только имя метода и список параметров, не содержит возвращаемый тип. Вызывается при создании нового объекта данного класса. Может выполнить инициализацию объекта.

Структуры - сущности для хранения данных, как и классы могут содержать данные-члены и функции-члены. Но в отличие от классов, структуры являются значимыми типами и для них выделяется память в стеке. Переменная типа структура напрямую хранит все свои данные, а переменная типа класс хранит ссылку на динамически выделяемый объект. Типы структуры не поддерживают определяемое пользователем наследование. Все типы структуры неявно наследуются от типа ValueType, который, в свою очередь, неявно наследуется от object.
	Although both class and structure are user-defined data types, they are different in several fundamental ways.
	A class is a reference type and stores on the heap. Struct, on the other hand, is a value type and is, therefore, stored on the stack.
	While the structure doesn’t support inheritance and polymorphism, the class provides support for both. A class can be of an abstract type, 
	but a structure can’t. All members of a class are private by default, while members of a struct are public by default. Another distinction 
	between class and struct is based on memory management. The former supports garbage collection while the latter doesn’t
	
Интерфейс - Интерфейсы, как и классы, определяют набор свойств, методов и событий. Но, в отличие от классов, они не содержат их реализации. Интерфейсы реализуются классами и определяются как самостоятельные сущности.

Тернарный оператор( ?: ) - используется для сокращения объема кода. Им можно заменять простые операторы if-else. Тернарный оператор имеет такую структуру:
	логическое выражение ? выражение1 : выражение2
	Сначала вычисляется логическое выражение. Если оно истинно, то вычисляется выражение1, в противном случае - вычисляется выражение2.
	Пример: Console.WriteLine( a % 2 == 0 ? "Число чётное" : "Число нечётное" );

Лямбда-выражения - это упрощенная запись анонимных методов. Они позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.

Инвариантность - позволяет использовать только заданный тип

Ковариантность - дает возможность приводить конкретные типы данных к общим в обобщенных интерфейсах.

Контвариантность - позволяет использовать общие типы взамен конкретных.

In - указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение параметра нельзя будет изменить. 

Event(Событие) - сигнализируют системе о том, что произошло определенное действие. И если нам надо отследить эти действия, то как раз мы можем применять события

Delegat(Делегат) - объектно-ориентированный способ работы с методом как с переменной. Его более привычный аналог — указатель на функцию. Делегат представляет собой тип, соответствующий определённой сигнатуре функции. Объявив переменную делегатного типа, вы можете записать в неё статический или нестатический метод, передать его как аргумент куда-либо, и вызвать. Классический пример использования делегатов — сортировка списка объектов по значению какого-либо поля. Вы передаёте в сортирующий метод делегат, который по объекту вычисляет ключ сортировки, то есть, вытаскивает значение поля.
	Ковариантность делегата - предполагает возможность возвращать из метода объект, тип которого является производным от типа, возвращаемого делегатом.
	Контвариантность - предполагает возможность передавать в метод объект, тип которого является более универсальным по отношению к типу параметра делегата.

Action - обобщенный делегат, принимает параметры и возвращает значение void: public delegate void Action<T>(T obj). Данный делегат имеет ряд перегруженных версий. Каждая версия принимает разное число параметров: от Action<in T1> до Action<in T1, in T2,....in T16>. Таким образом можно передать до 16 значений в метод.

Predicat<T> - делегат который принимает один параметр возвращает значение типа bool

Function(Func) - делегат возвращает результат действия и может принимать параметры

Анонимные методы - Анонимные методы используются для создания экземпляров делегатов. Анонимная функция, по существу, представляет собой безымянный кодовый блок, передаваемый конструктору делегата.  Преимущество анонимной функции состоит, в частности, в ее простоте. Благодаря ей отпадает необходимость объявлять отдельный метод, единственное назначение которого состоит в том, что он передается делегату.
	delegate int Sum(int number);

Абстрактный класс - похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. Единственное, что при определении абстрактных классов используется ключевое слово abstract. Но главное отличие состоит в том, что мы не можем использовать конструктор абстрактного класса для создания его объекта.
	Предоставляют следующие возможности:
	Создавать экземпляры абстрактного класса нельзя.
    Абстрактный класс может содержать абстрактные методы и методы доступа.
    Изменить абстрактный класс с модификатором sealed нельзя, так как два этих модификатора имеют взаимоисключающие значения.
	Модификатор sealed запрещает наследование класса, в то время как модификатор abstract указывает, что класс обязан иметь производные классы.
    Неабстрактный класс, производный от абстрактного класса, должен включать фактические реализации всех наследуемых абстрактных методов и методов доступа.

Интерфейс - тип, который определяет набор методов и свойств, но не реализует их. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы. Для определения интерфейса используется ключевое слово interface. Как правило, названия интерфейсов в C# начинаются с заглавной буквы I, например, IComparable, IEnumerable (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования. У интерфейса методы и свойства не имеют реализации, в этом они сближаются с абстрактными методами абстрактных классов. В данном случае интерфейс определяет метод Move, который будет представлять некоторое передвижение. Он не принимает никаких параметров и ничего не возвращает. Еще один момент в объявлении интерфейса: все его члены - методы и свойства не имеют модификаторов доступа, но фактически по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Поэтому весь функционал должен быть открыт для реализации.
	В целом интерфейсы могут определять следующие сущности: Методы, Свойства, Индексаторы, События.
	Однако интерфейсы не могут определять статические члены, переменные, константы.
	Интерфейс имеет следующие свойства:
    Интерфейс подобен абстрактному базовому классу, имеющему только абстрактные члены. Любой класс (или структура), реализующий интерфейс, должен реализовывать все его члены.
    Невозможно создать экземпляр интерфейса напрямую. Его члены реализуются любым классом (или структурой), реализующим интерфейс.
    Интерфейсы могут содержать события, индексаторы, методы и свойства.
    Класс или структура может реализовывать несколько интерфейсов. Класс может наследовать базовому классу и также реализовывать один или несколько интерфейсов.

Методы расширения - позволяют добавлять новые возможности к существующему типу. Вам не нужно вносить какие-либо изменения в существующий тип, просто принесите метод расширения в область видимости, и вы можете называть его как обычный метод экземпляра. Методы расширения должны быть объявлены в негенерированном, не вложенном, статическом классе

Статический класс - в основном такой же, как и нестатический класс, но имеется одно отличие: нельзя создавать экземпляры статического класса. Другими словами, нельзя использовать оператор new для создания переменной типа класса. Поскольку нет переменной экземпляра, доступ к членам статического класса осуществляется с использованием самого имени класса. Например, если есть статический класс, называемый UtilityClass, имеющий открытый статический метод с именем MethodA, вызов метода выполняется, как показано в следующем примере:  UtilityClass.MethodA(); Статические поля, методы, свойства относятся ко всему классу и для обращения к подобным членам класса необязательно создавать экземпляр класса. Память для статических переменных выделяется даже в том случае, если не создано ни одного объекта этого класса.

Статический конструктор - Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты: Статические конструкторы не должны иметь модификатор доступа и не принимают параметров. Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this для ссылки на текущий объект класса и можно обращаться только к статическим членам класса. Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются)

LINQ (Language Integrated Query) - интегрированный язык запросов.

Явная загрузка (Explicit loading) - Явная загрузка, как и отложенная загрузка, не приводит к загрузке всех связанных данных в первом запросе. Но при этом, в отличие от отложенной загрузки, при вызове навигационного свойства связанного класса, эта загрузка не приводит к автоматическому извлечению связанных данных, вы должны явно вызвать метод Load(), если хотите загрузить связанные данные. Такой тип загрузки может использоваться в следующих случаях:
    Этот тип загрузки устраняет необходимость отмечать навигационные свойства класса модели как виртуальные. Для вас это может показаться не значительным изменением, но тот факт, что технология доступа к связанным данным при отложенной загрузке требует изменять ваши классы POCO модели, далека от идеальной.
    Вы можете работать с существующей библиотекой классов, где навигационные свойства не помечены как виртуальные, и вы не можете изменить эту библиотеку.
    В конце концов явная загрузка позволяет быть уверенным, что вы точно знаете, когда запросы отправляются в базу данных. Отложенная загрузка имеет характерную особенность генерировать много запросов к базе данных, с явной загрузкой очевидно, когда и где запросы выполняются в настоящее время.

Ленивая\Отложенная загрузка (Lazy loading) - заключается в том, что Entity Framework автоматически загружает данные, при этом не загружая связанные данные. Когда потребуются связанные данные Entity Framework создаст еще один запрос к базе данных. В контексте нашего примера это означает, что вы можете, например, загрузить первого заказчика из таблицы Customers и сохранить его в переменной customer. Затем вам может понадобиться узнать, какие заказы связаны с этим покупателем. Напомню, в классе модели Customer у нас определено навигационное свойство Orders. Если вы обратитесь к этому свойству (customer.Orders), то Entity Framework отправит запрос в базу данных на извлечение всех связанных с этим покупателем заказов.
	Связанные объекты не загружаются, пока мы не проведем их итерацию или не свяжем их с данными. По умолчанию LINQ to SQL загружает связанные объекты, используя Lazy Loading.

Прямая\безотложная загрузка (Eager loading) - позволяет указать в запросе какие связанные данные нужно загрузить при выполнении запроса. Благодаря этому, когда в коде вы будете ссылаться на связанную таблицу через навигационное свойство, SQL-запрос не будет направляться в базу данных, т.к. связанные данные уже будут загружены при первом запросе. В Entity Framework для этих целей используется метод Include(), которому передается делегат, в котором можно указать навигационное свойство, по которому данные должны загружаться при первом запросе. Этот метод является расширяющим для IQueryable.

Жизненный цикл зависимостей - Все объекты, которые используются в ASP.NET Core, имеет три варианта жизненного цикла.
	Singleton - объект сервиса создается при первом обращении к нему, все последующие запросы используют один и тот же ранее созданный объект сервиса, к примеру, компоненты middleware или сервисы, которые регистрируются с помощью метода AddSingleton().
	Scoped: для каждого запроса создается свой объект сервиса. То есть если в течение одного запроса есть несколько обращений к одному сервису, то при всех этих обращениях будет использоваться один и тот же объект сервиса.
	Transient - при каждом обращении к сервису создается новый объект сервиса. В течение одного запроса может быть несколько обращений к сервису, соответственно при каждом обращении будет создаваться новый объект. Подобная модель жизненного цикла наиболее подходит для легковесных сервисов, которые не хранят данных о состоянии

Pattern (Паттерн) - Основные шаблоны проектирования, реализованные еще в 1977 году, делятся на три основные категории: порождающие (creational), структурные (structural) и поведенческие (behavioral), каждый из которых имеет определенную роль. Кроме того, вы можете найти модели, специфичные для пользовательского интерфейса, а также расширенные шаблоны для архитектурных задач. Эти модели являются членами новой классификации, также известной как архитектурная классификация шаблонов (architectural design patterns classification).
	Самое главная причина — паттерны упрощают проектирование и поддержку программ.
    Проверенные решения - Ваш код более предсказуем когда вы используете готовые решения, вместо повторного изобретения велосипеда.
    Стандартизация кода - Вы делаете меньше ошибок, так как используете типовые унифицированные решения, в которых давно найдены все скрытые проблемы.
    Общий язык - Вы произносите название паттерна, вместо того, чтобы час объяснять другим членам команды какой подход вы придумали и какие классы для этого нужны.
	https://refactoring.guru/ru/design-patterns/csharp

Поведенческие паттерн - шаблоны проектирования, которые определяют общие шаблоны взаимодействия между объектами. Повышают гибкость в осуществлении коммуникации

Структурные паттерны -  помогают из классов и объектов строить более крупные структуры. Структурные паттерны уровня класса используют наследование для составления композиций из интерфейсов и реализаций

Strategy (Стратегия) - поведенческий паттерн, определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
	 - выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.
	Применимость: Стратегия часто используется в C#-коде, особенно там, где нужно подменять алгоритм во время выполнения программы. Многие примеры стратегии можно заменить простыми lambda-выражениями.

Observer (Наблюдатель) - Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
	- поведенческий паттерн, который позволяет объектам оповещать другие объекты об изменениях своего состояния.
	Применимость: Наблюдатель можно часто встретить в C# коде, особенно там, где применяется событийная модель отношений между компонентами. Наблюдатель позволяет отдельным компонентам реагировать на события, происходящие в других компонентах.
	- уменьшает связанность за счёт обращения зависимостей. Он хорошо применим, когда есть несколько источников событий и много слушателей, которые добавляются динамически. Другим хорошим примером использования этого паттерна является реактивное программирование, когда изменение состояния одного объекта приводит к изменению состояния всех зависимых от него объектов и так далее.

Iterator (Итератор) - поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.
	Применимость: Паттерн можно часто встретить в C#-коде, особенно в программах, работающих с разными типами коллекций, и где требуется обход разных сущностей. Есть колекция элементов со сложной настройкой перехода от одного элемента к др с кучей параметров.

Command (Команда) - поведенческий паттерн, позволяющий заворачивать запросы или простые операции в отдельные объекты.
	- Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
	Применимость: Паттерн можно часто встретить в C#-коде, особенно когда нужно откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

Mediator (Посредник) - поведенческий паттерн. Уменьшает связанность системы за счёт того, что все зависимости уходят в один класс медиатор, а все остальные классы становятся независимы и отвечают только за логику, которую они выполняют. Таким образом, добавление новых классов становится проще, но с каждым новым классом логика медиатора сильно усложняется. С течением времени, если медиатор продолжает бесконтрольно разрастаться, то его становится очень тяжело поддерживать.
	Применимость: Пожалуй, самое популярное применение Посредника в C#-коде — это связь нескольких компонентов GUI одной программы.
    Когда имеется множество взаимосвязаных объектов, связи между которыми сложны и запутаны.
    Когда необходимо повторно использовать объект, однако повторное использование затруднено в силу сильных связей с другими объектами.
	Преимущества:
    Устраняется сильная связанность между объектами Colleague
    Упрощается взаимодействие между объектами: вместо связей по типу "все-ко-всем" применяется связь "один-ко-всем"
    Взаимодействие между объектами абстрагируется и выносится в отдельный интерфейс
    Централизуется управления отношениями между объектами

State (Состояние) - Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.
	Применимость: Паттерн Состояние часто используют в C# для превращения в объекты громоздких стейт-машин, построенных на операторах switch.

Template (Шаблон) - поведенческий паттерн, задающий скелет алгоритма в суперклассе и заставляющий подклассы реализовать конкретные шаги этого алгоритма.
	- Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
	Применимость: Шаблонные методы можно встретить во многих библиотечных классах C#. Разработчики создают их, чтобы позволить клиентам легко и быстро расширять стандартный код при помощи наследования.
	Например станок, который вытачивает разные детали из стандартных заготовок
Template Method (Шаблонный метод) - поведенческий паттерн, определяет основу алгоритма и позволяет подклассам переопределять некоторые шаги алгоритма, не изменяя его структуры в целом. Другими словами: ШМ — это каркас, в который наследники могут подставить реализации недостающих элементов. ШM позволяет создать небольшой каркас (framework) для решения определенной задачи, когда базовый класс описывает основные шаги решения, заставляя наследников предоставить недостающие куски головоломки.
Prototype (Прототип) - это порождающий паттерн, который позволяет копировать объекты любой сложности без привязки к их конкретным классам. Позволяет копировать объекты, не вдаваясь в подробности их реализации.
	Паттерн Прототип реализован в базовой библиотеке C# посредством интерфейса ICloneable
	
Subscriber (publisher-subscriber Издатель-подписчик) - поведенческий шаблон проектирования передачи сообщений, в котором отправители сообщений, именуемые издателями , напрямую не привязаны программным кодом отправки сообщений к подписчикам (англ. subscribers). Вместо этого сообщения делятся на классы и не содержат сведений о своих подписчиках, если таковые есть. Аналогичным образом подписчики имеют дело с одним или несколькими классами сообщений, абстрагируясь от конкретных издателей.
	Представляет собой расширение шаблона наблюдатель, в который добавлено описание канала событий , специально предназначенного для оповещения о событиях. 

Adapter (Адаптер) - структурный паттерн, который позволяет подружить несовместимые объекты. Позволяет объектам с несовместимыми интерфейсами работать вместе, переводить данные из одного формата в другой.
	Применимость: Паттерн можно часто встретить в C#-коде, особенно там, где требуется конвертация разных типов данных или совместная работа классов с разными интерфейсами.

Bridge (Мост) - структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.
	- Разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
	Применимость: Паттерн Мост особенно полезен когда вам приходится делать кросс-платформенные приложения, поддерживать несколько типов баз данных или работать с разными поставщиками похожего API (например, cloud-сервисы, социальные сети и т. д.)

Facade (Фасад) - структурный паттерн, который предоставляет простой (но урезанный) интерфейс к сложной системе объектов, библиотеке или фреймворку. Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
	Применимость: Паттерн часто встречается в клиентских приложениях, написанных на C#, которые используют классы-фасады для упрощения работы со сложными библиотеки или API.

Decorator (Декоратор) - структурный паттерн, позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». Для определения нового функционала в классах нередко используется наследование. Декораторы же предоставляет наследованию более гибкую альтернативу, поскольку позволяют динамически в процессе выполнения определять новые возможности у объектов.
	Применимость: Паттерн можно часто встретить в C#-коде, особенно в коде, работающем с потоками данных.

Builder — порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов. Часто можно встретить в C#-коде, особенно там, где требуется пошаговое создание продуктов или конфигурация сложных объектов.	
	
Factory (Фабрика) - порождающий паттерн, определяет интерфейс для создания объектов некоторого класса, но непосредственное решение о том, объект какого класса создавать происходит в подклассах. То есть паттерн предполагает, что базовый класс делегирует создание объектов классам-наследникам.
	Паттерн можно часто встретить в любом C#-коде, где требуется гибкость при создании продуктов.
	Применимость:
    Когда заранее неизвестно, объекты каких типов необходимо создавать
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.
    Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

Abstract factory - порождающий паттерн проектирования, позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов

Singleton (Синглтон) - порождающий паттерн, гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому объекту точку доступа.

Bootstrap - бесплатный набор инструментов для создания сайтов и веб-приложений. Включает в себя HTML- и CSS-шаблоны оформления для типографики, 
	веб-форм, кнопок, меток, блоков навигации и прочих компонентов веб-интерфейса, включая JavaScript-расширения.
	Bootstrap использует современные наработки в области CSS и HTML, поэтому необходимо быть внимательным при поддержке старых браузеров.

ORM (Object-Relational Mapping, объектно-реляционное отображение, или преобразование) - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». Существуют как проприетарные, так и свободные реализации этой технологии. Примеры Entity Framwork, ORM NHibernate, Linq2Sql, Gentle.Net, LightSpeed. Подходы ORM - Code First, Database-First, Model-First

WPF (Windows Presentation Foundation) - является часть экосистемы платформы .NET и представляет собой подсистему для построения графических интерфейсов. Если при создании традиционных приложений на основе WinForms за отрисовку элементов управления и графики отвечали такие части ОС Windows, как User32 и GDI+, то приложения WPF основаны на DirectX. В этом состоит ключевая особенность рендеринга графики в WPF: используя WPF, значительная часть работы по отрисовке графики, как простейших кнопочек, так и сложных 3D-моделей, ложиться на графический процессор на видеокарте, что также позволяет воспользоваться аппаратным ускорением графики. Одной из важных особенностей является использование языка декларативной разметки интерфейса XAML, основанного на XML: вы можете создавать насыщенный графический интерфейс, используя или декларативное объявление интерфейса, или код на управляемых языках C# и VB.NET, либо совмещать и то, и другое

WCF (Windows Communication Foundation) - это платформа для создания приложений, ориентированных на службы. С помощью WCF можно передавать данные в виде асинхронных сообщений из одной конечной точки службы в другую. Конечная точка службы может входить в постоянно доступную службу, размещаемую в IIS, или представлять службу, размещаемую 	в приложении. Конечная точка может быть клиентом службы, которая запрашивает данные от конечной точки службы. Сообщения могут представлять одиночный символ или одно слово, отправляемое в формате XML, или иметь вид сложного потока двоичных данных

SOLID (single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) - мнемонический акроним, введённый Майклом Фэзерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. 
	S (Single Responsibility) Принцип единственной ответственности Этот принцип означает, что каждый класс или подобная структура в вашем коде должна отвечать только за одну цель. Все члены этого класса должны быть связаны одной целью. Наш класс не должен быть похож на швейцарский нож, в котором при изменении одного из членов нужно изменять весь инструментарий. Это не означает, что ваши классы должны содержать только один метод или свойство. Может быть много членов, если они относятся к одной задаче
	O (Open Closed Principle) Принцип открытости/закрытости. Главной концепцией данного принципа является то, что класс должен быть открыт для расширений, но закрыт от модификаций. Наш модуль должен быть разработан так, чтобы новая функциональность могла быть добавлена только при создании новых требований. «Закрыт для модификации» означает, что мы уже разработали класс, и он прошел модульное тестирование. Мы не должны менять его, пока не найдем ошибки. Как говорится, класс должен быть открытым только для расширений и в C# мы можем использовать для этого наследование
	L (Liskov Substitution Principle)Принцип подстановки Барбары Лисков «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.
	I (Interface Segregation Principle)Принцип разделения интерфейса «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
	D (Dependency Inversion Principle)Принцип инверсии зависимостей «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.» Мы должны держать высокоуровневые и низкоуровневые классы слабо связанными, насколько мы можем. Чтобы сделать это, нам нужно сделать их зависимыми от абстракций, а не друг от друга

KPI (Key Performance Indicator) - индикатор эффективности и успешности выполнения поставленных целей. Ключевой индикатор выполнения. Проще говоря, это показатель достижения результата в той или иной деятельности, который возможно оцифровать и измерить. Мотивационная система KPI - в русской версии иногда используют аббревиатуру КПЭ (ключевые показатели эффективности)

DI (Dependency injection\Внедрение зависимостей) - стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. DI - это альтернатива самонастройке объектов. Dependency injection (DI) или внедрение зависимостей представляет механизм, который позволяет сделать взаимодействующие в приложении объекты слабосвязанными. Такие объекты связаны между собой через абстракции, например, через интерфейсы, что делает всю систему более гибкой, более адаптируемой и расширяемой. Нередко для установки зависимостей в подобных системах используются специальные контейнеры - IoC-контейнеры (Inversion of Control). Такие контейнеры служат своего рода фабриками, которые устанавливают зависимости между абстракциями и конкретными объектами и, как правило, управляют созданием этих объектов. И если раньше в ASP.NET 4 и других предыдщих версиях надо было использовать различные внешние IoC-контейнеры для установки зависимостей, такие как Ninject, Autofac, Unity, Windsor Castle, StructureMap, то ASP.NET Core уже имеет встроенный контейнер внедрения зависимостей, который представлен интерфейсом IServiceProvider. А сами зависимости еще называются сервисами, собственно поэтому контейнер можно назвать провайдером сервисов. Этот контейнер отвечает за сопоставление зависимостей с конкретными типами и за внедрение зависимостей в различные объекты
    - Используется интерфейс или базовый класс для абстрагирования реализации зависимостей.
	- Зависимость регистрируется в контейнере служб. .NET предоставляет встроенный контейнер служб IServiceProvider. Службы обычно регистрируются при запуске и добавляются в IServiceCollection приложение. После добавления всех служб выполните BuildServiceProvider для создания контейнера службы.
    - Служба внедряется в конструктор класса там, где он используется. Платформа берет на себя создание экземпляра зависимости и его удаление, когда он больше не нужен.

AutoFack (DI-контейнер) - is an addictive IoC container for .NET. It manages the dependencies between classes so that applications stay easy to change as they grow in size and complexity. This is achieved by treating regular .NET classes as components.
	это захватывающий контейнер IoC для .NET. Он управляет зависимостями между классами, так что приложения остаются легкими для изменения
	как они растут в размерах и сложности. Это достигается обработкой обычных классов .NET как компонентов.
	
Automapper - позволяет проецировать одну модель на другую, что позволяет сократить объемы кода и упростить программу.

IoC (Inversion of Control инверсия управления) - это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.

SQL (structured query language) - структурированный язык запросов. - это декларативный язык запросов к данным в определённом типе баз данных (реляционном).
	- декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей 
	системой управления базами данных.
	- язык, если точнее, множество стандартов языка. Вы можете написать запрос на SQL, но исполнить его может только конкретная СУБД.

Реляционная база данных - это связанная информация, представленная в виде двумерных таблиц. Представьте себе адресную книгу. Она содержит множество строк, каждая из которых соответствует данному индивидууму. Для каждого из них в ней представлены некоторые независимые данные, например, имя, номер телефона, адрес. Представим такую адресную книгу в виде таблицы, содержащей строки и столбцы. Каждая строка (называемая также записью) соответствует определенному индивидууму, каждый столбец содержит значения соответствующего типа данных: имя, номер телефона и адрес, представленных в каждой строке. 
	Нереляционная база данных - это база данных, в которой в отличие от большинства традиционных систем баз данных не используется табличная схема строк и столбцов. В этих базах данных применяется модель хранения, оптимизированная под конкретные требования типа хранимых данных. Например, данные могут храниться как простые пары "ключ - значение", документы JSON или граф, состоящий из ребер и вершин.

MySQL / MariaDB / PostgreSQL - различные реляционные СУБД, выполняющие запросы.

MySQL и MS SQL - это две системы баз данных.
	MYSQL является открытым исходным кодом, в то время как MS SQL является закрытым источником
	MYSQL бесплатно использовать, а MS SQL требует оплаты лицензии на использование
	MySQL использует меньшее дисковое пространство; MS SQL использует более высокое дисковое пространство
	MySQL крест совместим с другими платформами, такими как Unix и Linux
	MS SQL несовместим с другими платформами
	MySQL не использует внешние ключи, в то время как MS SQL поддерживает их использование

CRUD - basic functions of a computer database(create, read, update, and delete)

Нормализация - это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами, которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.

MongoDB - документоориентированная система управления базами данных, не требующая описания схемы таблиц. Считается одним из классических примеров NoSQL-систем, использует JSON-подобные документы и схему базы данных. Применяется в веб-разработке, в частности, в рамках JavaScript-ориентированного стека MEAN. MongoDB реализует новый подход к построению баз данных, где нет таблиц, схем, запросов SQL, внешних ключей и многих других вещей, которые присущи объектно-реляционным базам данных. Со времен динозавров было обычным делом хранить все данные в реляционных базах данных (MS SQL, MySQL, Oracle, PostgresSQL). При этом было не столь важно, а подходят ли реляционные базы данных для хранения данного типа данных или нет. В отличие от реляционных баз данных MongoDB предлагает документо-ориентированную модель данных, благодаря чему MongoDB работает быстрее, обладает лучшей масштабируемостью, ее легче использовать.

Внешние ключи (FOREIGN KEY) - создается между двумя таблицами, чтобы связать строки одной таблицы со строками другой

Join - Присоединение таблиц в запросах. Базовый инструмент в работе с базами данных. Оператор MySQL LEFT JOIN позволяет запрашивать данные из двух или более таблиц базы данных. Он является необязательной частью оператора SELECT, которая указывается после FROM.

Индекс - это объект базы данных, который представляет собой структуру данных, состоящую из ключей, построенных на основе одного или нескольких столбцов таблицы или представления, и указателей, которые сопоставляются с местом хранения заданных данных. Индексы предназначены для более быстрого получения строк из таблицы, другими словами, индексы обеспечивают быстрый поиск данных в таблице, что значительно повышает производительность запросов и приложений. Индексы также могут быть использованы и для обеспечения уникальности строк таблицы, гарантируя тем самым целостность данных.
	
	Типы индексов в Microsoft SQL Server:
    Clustered (Кластеризованный) – это индекс, который хранит данные таблицы в отсортированном, по значению ключа индекса, виде. У таблицы может быть только один кластеризованный индекс, так как данные могут быть отсортированы только в одном порядке. По возможности каждая таблица должна иметь кластеризованный индекс, если у таблицы нет кластеризованного индекса, такая таблица называется «кучей». Кластеризованный индекс создается автоматически при создании ограничений PRIMARY KEY (первичный ключ) и UNIQUE, если до этого кластеризованный индекс для таблицы еще не был определен. В случае создания кластеризованного индекса для таблицы (кучи), в которой есть некластеризованные индексы, то после создания все их необходимо перестроить.
    Nonclustered (Некластеризованный) – это индекс, который содержит значение ключа и указатель на строку данных, содержащую значение этого ключа. У таблицы может быть несколько некластеризованных индексов. Создаваться некластеризованные индексы могут как на таблицах с кластеризованным индексом, так и без него. Именно этот тип индекса используется для повышения производительности часто используемых запросов, так как некластеризованные индексы обеспечивают быстрый поиск и доступ к данным по значениям ключа;
    Фильтруемый (Filtered) – это оптимизированный некластеризованный индекс, который использует предикат фильтра для индексирования части строк в таблице. Если хорошо спроектировать такой тип индекса, то он может повысить производительность запросов, а также снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными индексами;
    Уникальный (Unique) – это индекс, который обеспечивает отсутствие повторяющихся (одинаковых) значений ключа индекса, гарантируя тем самым уникальность строк по данному ключу. Уникальными могут быть как кластеризованные, так и некластеризованные индексы. Если создавать уникальный индекс по нескольким столбцам, индекс гарантирует уникальность каждой комбинации значений в ключе. При создании ограничений PRIMARY KEY или UNIQUE SQL сервер автоматически создает уникальный индекс для ключевых столбцов. Уникальный индекс может быть создан только в том случае, если у таблицы на текущий момент отсутствуют дублирующие значения по ключевым столбцам;
    Колоночный (Columnstore) – это индекс, основанный на технологии хранения данных в виде столбцов. Данный тип индекса эффективно использовать для больших хранилищ данных, поскольку он может увеличить производительность запросов к хранилищу до 10 раз и также до 10 раз уменьшить размер данных, так как данные в Columnstore индексе сжимаются. Существуют как кластеризованные колоночные индексы, так и некластеризованные;
    Полнотекстовый (Full-text) – это специальный тип индекса, который обеспечивает эффективную поддержку сложных операций поиска слов в символьных строковых данных. Процесс создания и обслуживания полнотекстового индекса называется «заполнением». Существует такие типы заполнения как: полное заполнение и заполнение на основе отслеживания изменений. По умолчанию SQL сервер полностью заполняет новый полнотекстовый индекс сразу после его создания, но на это может потребоваться значительный объем ресурсов, в зависимости от размеров таблицы, поэтому есть возможность откладывать полное заполнение. Заполнение на основе отслеживания изменений используется для обслуживания полнотекстового индекса после его первоначального полного заполнения;
    Пространственный (Spatial) – это индекс, который обеспечивает возможность более эффективного использования конкретных операций на пространственных объектах в столбцах с типом данных geometry или geography. Данный тип индекса может быть создан только для пространственного столбца, также таблица, для которой определяется пространственный индекс, должна содержать первичный ключ (PRIMARY KEY);
    XML – это еще один специальный тип индекса, который предназначен для столбцов с типом данных XML. Благодаря XML-индексу повышается эффективность обработки запросов к XML столбцам. Существует два вида XML-индекса: первичные и вторичные. Первичный XML-индекс индексирует все теги, значения и пути, хранимые в XML столбце. Он может быть создан, только если у таблицы есть кластеризованный индекс по первичному ключу. Вторичный XML-индекс может быть создан, только если у таблицы есть первичный XML-индекс и используется он для повышения производительности запросов по определенному типу обращения к XML-столбцу, в связи с этим существует несколько типов вторичных индексов: PATH, VALUE и PROPERTY;
    Также существуют специальные индексы для таблиц, оптимизированных для памяти (In-Memory OLTP) такие как: Хэш (Hash) индексы и некластеризованные индексы, оптимизированные для памяти, которые создаются для сканирования диапазона и упорядоченного сканирования.

Констрейнты SQL - это набор правил, применённый к данным колонок в таблице. Они используются для ограничения типов данных, которые могут храниться в таблице. 
	Это также обеспечивает точность и читабельность данных в БД. Значения могут применять как к колонке, так и ко всей таблице.

Триггеры - хранимая процедура, которая не вызывается непосредственно, а исполняется при наступлении определенного события ( вставка, удаление, обновление строки ).
	after update указывает, что триггер срабатывает после выполнения оператора UPDATE.
	
Триггеры - специальный тип хранимой процедуры, которая вызывается автоматически при выполнении определенного действия над таблицей или представлением, в частности, при добавлении, изменении или удалении данных, то есть при выполнении команд INSERT, UPDATE, DELETE.	
	
Транзакции - позволяют выполнять ряд операций в виде одного целостного пакета. И если хотя бы одна из этих операций завершится неудачно, то произойдет откат выполнения остальных операций.
	
Уровни изолированности транзакций - Read uncommitted, Read committed, Repeatable read, Serializable.
	Read uncommitted - уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций. Название уровня говорит само за себя — каждая транзакция видит незафиксированные изменения другой транзакции (феномен грязного чтения)
	Read committed - Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким образом, данный уровень обеспечивает защиту от грязного чтения.
	Repeatable read (Snapshot level) - Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией. Но все еще видим вставленные записи из другой транзакции. Чтение фантомов никуда не уходит. 
	Serializable - обеспечивает самую строгую изоляцию транзакций. На этом уровне моделируется последовательное выполнение всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не параллельно. Однако, как и на уровне Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбоев сериализации. Фактически этот режим изоляции работает так же, как и Repeatable Read, только он дополнительно отслеживает условия, при которых результат параллельно выполняемых сериализуемых транзакций может не согласовываться с результатом этих же транзакций, выполняемых по очереди

	Уровень изоляции транзакции      ||"Грязных" операций чтения||Неповторяемые операции чтения||Фантомы
	Уровень изоляции read uncommitted||	X 	X 	X
	Уровень изоляции read committed  ||	-- 	X 	X
	Уровень изоляции repeatable read ||	-- 	-- 	X
	Упорядочиваемый уровень изоляции ||	-- 	-- 	--
	Serializable
	
	"Грязные" операции чтения - «Грязное» чтение происходит, когда транзакция считывает данные, которые еще не были зафиксированы. Например, транзакция 1 обновляет строку. Транзакция 2 считывает обновленную строку до того, как транзакция 1 зафиксирует обновление. Если транзакция 1 выполняет откат изменений, то транзакция 2 будет считать данные, которые никогда не существовали.
	
	Неповторяемые операции чтения - происходит, когда транзакция дважды считывает одну и ту же строку, но получает разные данные. Например, транзакция 1 считывает строку. Транзакция 2 обновляет или удаляет эту строку и фиксирует обновление или удаление. Если транзакция 1 пересчитывает строку, она получает различные значения строки или обнаруживает, что строка была удалена.
	
	Фантомы — это строка, которая соответствует условиям поиска, но изначально не отображается. Например, транзакция 1 считывает набор строк, удовлетворяющих некоторым условиям поиска. Транзакция 2 создает новую строку (посредством обновления или вставки), которая соответствует условиям поиска для транзакции 1. Если транзакция 1 выполняет инструкцию, которая считывает строки, она получает другой набор строк.

Сага - представляет собой набор локальных транзакций. Каждая локальная транзакция обновляет базу данных и публикует сообщение или событие, инициируя следующую 
	локальную транзакцию в саге. Если транзакция завершилась неудачей, например, из-за нарушения бизнес правил, тогда сага запускает компенсирующие транзакции, 
	которые откатывают изменения, сделанные предшествующими локальными транзакциями.

Двухфазный коммит - это коммит из двух фаз. Первая фаза - атомарная операция по проверке возможности начала транзакции и блокировки участников коммита. Вторая фаза - сбор ответов от участников и применение транзакции с отпусканием блокировок. Отказоустойчивый коммит - коммит, который продолжает исполняться даже при условии отказа одного или нескольких участников коммита.

Монолитный сервер - вся логика по обработке запросов выполняется в единственном процессе, при этом вы можете использовать возможности вашего языка программирования для разделения приложения на классы, функции и namespace-ы. Вы можете запускать и тестировать приложение на машине разработчика и использовать стандартный процесс развертывания для проверки изменений перед выкладыванием их в продакшн. Вы можете масштабировать монолитное приложения горизонтально путем запуска нескольких физических серверов за балансировщиком нагрузки. Один из главных минусов монолтиа - любые изменения, даже самые небольшие, требуют пересборки и развертывания всего монолита

Микросервисы - это подход, при котором единое приложение строится как набор небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя легковесные механизмы, как правило HTTP. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо с использованием полностью автоматизированной среды. Существует абсолютный минимум централизованного управления этими сервисами. Сами по себе эти сервисы могут быть написаны на разных языках и использовать разные технологии хранения данных.
	Для того, чтобы начать рассказ о стиле микросервисов, лучше всего сравнить его с монолитом (monolithic style): приложением, построенном как единое целое. Enterprise приложения часто включают три основные части: пользовательский интерфейс (состоящий как правило из HTML страниц и javascript-а), база данных (как правило реляционной, со множеством таблиц) и сервер. Серверная часть обрабатывает HTTP запросы, выполняет доменную логику, запрашивает и обновляет данные в БД, заполняет HTML страницы, которые затем отправляются браузеру клиента. 
	Любое изменение в системе приводит к пересборке и развертыванию новой версии серверной части приложения

Распределенная транзакция — это транзакция, затрагивающая несколько ресурсов. Для фиксации распределенной транзакции все участники должны гарантировать, что любое изменение данных будет постоянным. Изменения должны сохраняться даже в случае фатального сбоя системы или других непредвиденных событий. Если хоть один из участников не сможет предоставить такую гарантию, вся транзакция завершится с ошибкой и будет выполнен откат любых изменений данных внутри области транзакции.

ETL (Extract, Transform, Load) – извлечение, преобразование, загрузка. Процесс в современном дата-стеке, который извлекает данные из сторонних баз данных или ПО, преобразует их и загружает в хранилище данных. Инструменты ETL используют, когда нужно быстро перенести много разнородных данных. Такие решения автоматизируют процесс и экономят ресурсы, потому что вам не придётся создавать собственные конвейеры данных

IDE (Integrated Development Environment) - Интегрированная среда разработки система программных средств, используемая программистами для разработки программного обеспечения.

MVC (model view controller) - Платформа ASP.NET MVC представляет собой фреймворк для создания сайтов и веб-приложений с помощью реализации паттерна MVC.
	MVC  предполагает разделение приложения на три компонента:
	Контроллер (controller) представляет класс, обеспечивающий связь между пользователем и системой, представлением и хранилищем данных. Он получает вводимые пользователем 
	данные и обрабатывает их. И в зависимости от результатов обработки отправляет пользователю определенный вывод, например, в виде представления.
	Представление (view) - это собственно визуальная часть или пользовательский интерфейс приложения. Как правило, html-страница, которую пользователь видит, зайдя на сайт.
	Модель (model) представляет класс, описывающий логику используемых данных.

AsQueryable(IEnumerable) - Преобразовывает коллекцию IEnumerable в объект IQueryable.

Yield - Используется в блоке итератора для предоставления значения объекта перечислителя.

Reflection - представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения

Условная компиляция - Директивы условной компиляции позволяют в зависимости от условий добавить в файл определенный код. Прежде всего это такие директивы как 
	#if/#else/#endif, действие которых напоминает условную конструкцию if

Swagger - это фреймворк и спецификация для определения REST APIs в формате, дружественном к пользователю и компьютеру (в нашем случае JSON или YAML).
	Он дает возможность не только интерактивно просматривать спецификацию, но и отправлять запросы через Swagger UI.
	
Константы - Константы предназначены для описания таких значений, которые не должны изменяться в программе. Для определения констант используется ключевое слово const:
	При использовании констант надо помнить, что объявить мы их можем только один раз и что к моменту компиляции они должны быть определены.

readonly(поля для чтения) - можно инициализировать при их объявлении либо на уровне класса, либо инициилизировать и изменять в конструкторе. Инициализировать или изменять их значение в других местах нельзя, можно только считывать их значение. Доступные только для чтения поля инициализируются во время выполнения, константы - во время компиляции
	
Атрибуты - в .NET представляют специальные инструменты, которые позволяют встраивать в сборку дополнительные метаданные. Атрибуты могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). Основу атрибутов составляет класс System.Attribute, от которого образованы все остальные классы атрибутов.
	- универсальное средство связи данных с типами, позволяют добавлять любую текстовую информацию о классах, свойствах, методах и т.д. Атрибуты сохраняются с метаданными и могут быть получены при выполнении программы.
	Прим: [AgeValidation(18)], [Serializable], [NonSerialized].
	
CLR (Common Language Runtime общеязыковая исполняющая среда) - исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.  CLR компилирует код приложения на языке CIL (реализация компиляции которого компанией Microsoft называется MSIL) во время его исполнения, а также предоставляет MSIL-программам  (а следовательно, и программам, написанным на языках высокого уровня, поддерживающих .NET Framework) доступ к библиотеке классов .NET Framework, или так называемой .NET FCL (англ. Framework Class Library).

IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

CLS (Common Language Specification, общеязыковая спецификация) - набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

Assembly (Сборка) - один или несколько файлов, содержащий логический набор функциональности (код и другие данные, связанные с кодом). Бывают статические сборки, хранящиеся на диске, и динамические, которые создаются во время выполнения программы. Сборка - это базовый блок приложения, все ресурсы, относящиеся к ней, доступны или только внутри этого блока, или экспортируются наружу. При выполнении сборка задает область видимости имен и следит за ее соблюдением

Assembly manifest (Манифест сборки) - внутренняя часть сборки, которая позволяет ей быть самоописанной. Assembly manifest позволяет идентифицировать сборку, указывает файлы, которые включаются в реализацию сборки, описывает типы и ресурсы, используемые в сборке, указывает зависимости от других сборок, а также набор прав доступа, которые необходимы сборке для корректной работы. Эта информация используется во время выполнения для разрешения ссылок, проверку корректности версий, проверку целостности загруженных сборок.

CAS (Code Access Security) - защитная технология, позволяющая установить ограничение на исполнение управляемого кода. Таким образом можно определить разрешения и установить права доступа к ресурсам компьютера

ADO.NET - часть фреймфорка .NET, предоставляющая доступ к данным для приложений, основанных на Microsoft .NET. Не является развитием более ранней технологии ADO, а является самостоятельной технологией. Классы ADO.NET находятся в сборке System.Data.dll Многие другие части фреймворка .Net, как и сторонние библиотеки, используют те или иные части ADO.NET. Например:
    Части .Net Framework, Entity Framework, Linq to SQL, Сторонние библиотеки.
	 - часть Microsoft .NET Framework, т.е. набор средств и слоев, позволяющих приложению легко управлять и взаимодействовать со своим файловым или серверным хранилищем данных. В NET Framework библиотеки ADO.NET находится в пространстве имени System.Data. Эти библиотеки обеспечивают подключение к источникам данных, 
	выполнении команд, а также хранилище, обработку и выборку данных. ADO.NET отличается от предыдущих технологий доступа к данным тем, что она позволяет взаимодействовать с базой данных автономно, с помощью от базы кеша данных.

Фреймворк - программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.
	
Set - Интерфейс расширяет интерфейс Collection и представляет набор уникальных элементов. Set не добавляет новых методов, только вносит изменения унаследованные. 
	В частности, метод add() добавляет элемент в коллекцию и возвращает true, если в коллекции еще нет такого элемента.

HashSet - представляет хеш-таблицу. Он наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set.
	Хеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице.

Credential - учетные данные, полномочия, верительные грамоты, мандат, явки, пароли.

Credential Guard (Защита учётной записи) - изолирует секреты с помощью основанных на виртуализации технологий, так что только привилегированные системы могут получить к ним доступ.
	Предоставляет следующие возможности:
    Безопасность оборудования. Повышает безопасность учётных записей производного домена, используя для этого преимущества функций безопасности платформы, включая безопасную загрузку и виртуализацию.
    Безопасность на основе виртуализации. Службы Windows, которые управляют учётными данными производного домена и другими секретами, выполняются в защищённой среде, изолированной от операционной системы.
    Улучшенная защита от самых современных постоянных угроз. Обеспечивает учётные данные производных доменов с помощью безопасности на основе виртуализации. Блокирует атаки на учётные данные и инструменты, используемые в многих других атаках. Вредоносные программы, выполняющимися в ОС с административными привилегиями не могут извлечь секреты, которые находятся под защитой безопасности на основе виртуализации.
    Управляемость. Управление с помощью групповой политики, WMI, из командной строки и Windows PowerShell.

Interseptor - перехватчик запросов.

Query Builder - конструктор запросов предоставляет удобный, выразительный интерфейс для создания и выполнения запросов к базе данных. Он может использоваться для выполнения большинства типов операций и работает со всеми подерживаемыми СУБД
	
CallBack - функция обратного вызова, передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове. Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), которые естественным образом задаются как обратные вызовы. 

API(Application Program Interface) - или программный интерфейс приложения. Это определенный набор протоколов, подпрограмм и инструментов для создания программных приложений. Проще говоря, это инструментарий разработчика. Получается программный интерфейс приложений. Или, точнее, написания приложений. А попросту - библиотека. Собственно, используется для того, чтобы написать программу, выполняющую те или иные, нужные нам действия.
	- Это набор правил, позволяющий программам «общаться» друг с другом. Разработчик создает API на сервере и позволяет клиентам обращаться к нему.

REST (Representational State Transfer «передача репрезентативного состояния» или «передача „самоописываемого“ состояния») - архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.REST представляет собой согласованный набор ограничений. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. В интернете вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве параметров запроса.
	Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».
	В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство RESTful-реализаций используют такие стандарты, как HTTP, URL, JSON и, реже, XML. 
	Принципы REST
	1. Независимость состояния (Statelessness) Да, RESTful сервис должен быть как идеальный суд – его не должно интересовать ни прошлое подсудимого (клиента), ни будущее. Он просто выносит приговор (отвечает на запрос).
	2. Кэшируемая и многоуровневая архитектура (любое количество элементов middleware на сервере)
	3. Клиент – серверное разделение
	4. Удобное предоставление данных
	5. Для разграничения действий с ресурсами на уровне HTTP-методов и были придуманы следующие варианты GET — получение, POST — создание, PUT — обновление, DELETE — удаление, PATCHE - частичное изменение
	6. Также исползование HTTP-кодов при получении ответов 2xx, 3xx, 4xx, 5xx.
	https://www.youtube.com/watch?v=we4NVJtY_4E

RESTful - Сервер может считаться RESTful, если он соответствует принципам REST

SOAP (Simple Object Access Protocol простой протокол доступа к объектам) - стандартизированый протокол, требуют использования XML в качестве формата полезной нагрузки, обычно через HTTP
	- это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.
	SOAP используют HTTP как транспортный протокол, в то время как REST базируется на нем. Это означает, что все существующие наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование, продолжают так же работать в REST архитектуре, а для SOAP необходимо искать другие средства. REST может быть представлен в различных форматах, а SOAP привязан к XML.
	«REST vs SOAP» можно перефразировать в «Простота vs Стандарты»
	SOAP работает с операциями, а REST – с ресурсами

Pipelin \ HTTP pipelin (Конвейер обработки) - программное обеспечение, задача которого состоит в получении запроса, его обработке и отклике. Состоит оно из конвейера обработчиков (Middleware таких как Logger, Authentication, Cors, Mvc и.т.д.) Каждый компонент поочередно обрабатывает запрос по своему, после чего определяет нужно ли передать запрос следующему компоненту в конвейера или прервать его. Прерывание запроса также важно, т.к. чем раньше происходит прерываие тем меньше будет нагрузки на остальные компоненты, соответственно и меньше нагрузка на сервер. Так же могут выполнять работу как до, так и после вызова следующего компонента в конвейере. В ASP.NET Core для подключения компонентов в основном используется метод Configure в классе Startup, а загружаются через nuget package manager. Но могут быть и кастомными. 
	Порядок и расположение компонентов имеет значение.
	Для создания и управления конвейера запроса используются делегаты Run, Use и Map:
	app.Run() Этот метод добавляет middleware-компонент в виде Run[Middleware], который выполнится в конце конвейера. Как правило, он действует как замыкающее middleware и добавляется в конце конвейера запросов, поскольку не может вызывать следующий middleware-компонент.
	app.Use() Этот метод используется для конфигурирования нескольких middleware. В отличие от app.Run(), мы можем включить в него параметр next, который вызывает следующий делегат запроса в конвейере. Мы также можем замкнуть (завершить) конвейер, не вызывая параметр next. 
	app.Map() Этот метод расширения используются как условное обозначение для ветвления конвейера. Map разветвляет конвейер запросов на основе пути запроса. Если путь запроса начинается с указанного пути, ветвь выполняется.

IS - позволяет сравнить объект и тип данных, что бы определить принадлежит ли наш объект этому типу. Возвращает данная конструкция либо true либо false

AS - служит для перевода объекта к указанному типу, в случае невозможности привести объект к указанному типу мы вместо исключения получим null

ISet<T> - 	Интерфейс предоставляющий методы для создания объединения нескольких множеств, пересечения множеств и определения, является ли одно множество надмножеством или подмножеством другого.

HashSet<T> и SortedSet<T> - Коллекция, содержащая только отличающиеся элементы, называется множеством (set). В составе .NET 4 имеются два множества - HashSet<T> и SortedSet<T>. Оба они реализуют интерфейс ISet<T>. Класс HashSet<T> содержит неупорядоченный список различающихся элементов, а в SortedSet<T> элементы упорядочены.

Dictionary (Словарь) -  представляет собой сложную структуру данных, позволяющую обеспечить доступ к элементам по ключу. Главное свойство словарей - быстрый поиск на основе ключей. Можно также свободно добавлять и удалять элементы, подобно тому, как это делается в List<T>, но без накладных расходов производительности, связанных с необходимостью смещения последующих элементов в памяти.

Partial Class (Разделяемые классы) -  Можно разделить определение класса, структуры, интерфейса или метода между двумя или более исходными файлами. Каждый исходный файл содержит часть определения класса или метода, а во время компиляции приложения все части объединяются.
	Существует несколько ситуаций, когда желательно разделение определения класса.
    При работе над большими проектами распределение класса между различными файлами позволяет нескольким программистам работать с ним одновременно.
    При работе с использованием автоматически создаваемого источника код можно добавлять в класс без повторного создания файла источника. 
	Visual Studio использует этот подход при создании форм Windows Forms, кода оболочки веб-службы и т. д. Можно создать код, который использует эти классы, без необходимости изменения файла, созданного в Visual Studio.

Капча - компьютерный тест, используемый для того, чтобы определить, кем является пользователь системы: человеком или компьютером.

Using - Синтаксический сахар, что-то вроде обертки над объектами, которые реализуют интерфейс IDisposable, благодаря которому не нужно следить за утечкой памяти, при завершении блока кода и даже в случае каких то сбоев автоматический запускается очистка памяти методом Dispose. Важно, что данная конструкция применяется только для классов, которые реализуют интерфейс IDisposable и его метод Dispose.

Кастомный - это переделанный под потребителя, собранный заново, вручную. Относится к любому изделию, которое изменено под конкретную аудиторию.

Конкатенация (лат. сцепление) - операция склеивания объектов линейной структуры, обычно строк.

CORS (cross-origin resource sharing/совместное использование ресурсов из разных источников) - это механизм безопасности, который позволяет веб-странице из одного домена обращаться к ресурсу с другим доменом (кросс-доменным запросом). Без таких функций, как CORS, веб-сайты ограничиваются доступом к ресурсам одного и того же происхождения через так называемую политику единого происхождения

Pull request (Пул реквест) - запрос к управляющему каким-либо репозиторием (человеку, группе людей или вообще роботу) на применение изменений (из вашего репозитория и/или указанной вами ветки). Часто пул реквест делают из репозитория-форка в исходный репозиторий.

WSDL (Web Services Description Language) – язык описания веб-сервисов и доступа к ним, основанный на языке XML. На нем описываются методы, входные и результирующие структуры данных, типы данных, сетевые адреса для обращения к сервису и другое.

Newtonsoft - soft для сериализации, десериализации JSON

Мок - настраиваемый объект, который имитирует поведение реального объекта.

Unix-время (англ. Unix time, также POSIX-время) — система описания моментов во времени, принятая в Unix и других POSIX-совместимых операционных системах. Определяется как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (четверг); этот момент называют «эпохой Unix» (англ. Unix Epoch). 

Сквозное шифрование (end-to-end encryption) - способ передачи данных, в котором только пользователи, участвующие в общении, имеют доступ к сообщениям. Таким образом, использование сквозного шифрования не позволяет получить доступ к криптографическим ключам со стороны третьих лиц. Для обмена ключами могут быть применены симметричный и асимметричный алгоритмы. Сквозное шифрование предполагает, что ключи шифрования известны только общающимся между собой сторонам. Для реализации данного условия может быть использована схема с предварительным разделением секрета или, например, протокол Диффи-Хелмана, который используется в мессенджерах WhatsApp и Telegram
	https://pikabu.ru/story/kak_rabotaet_endtoend_shifrovanie_metod_vzlamyivaetsya_oshibka_5411489


DTO (Data Transfer Object) - один из шаблонов проектирования, используется для передачи данных между подсистемами приложения. Data Transfer Object, в отличие от business object или data access object не должен содержать какого-либо поведения. 

DWH (data warehouse) - хранилище данных, необходима для того, чтобы делать BI — business intelligence. Бизнес-аналитика — это процесс анализа данных и получения информации, помогающей компаниям принимать решения.
	— предметно-ориентированная информационная база данных, специально разработанная и предназначенная для подготовки отчётов и бизнес-анализа с целью поддержки принятия решений в организации. Строится на базе систем управления базами данных и систем поддержки принятия решений. Данные, поступающие в хранилище данных, как правило, доступны только для чтения.

Масштабируемость (scalability) — в электронике и информатике означает способность системы, сети или процесса справляться с увеличением рабочей нагрузки (увеличивать свою производительность) при добавлении ресурсов

Идемподентность — действие, многократное повторение которого эквивалентно однократному. Примером такой операции могут служить GET-запросы в протоколе HTTP. По спецификации, сервер должен возвращать идентичные ответы на идентичные GET-запросы (при условии, что ресурс не изменился). Это позволяет корректно кэшировать эти ответы, снижая нагрузку на сеть.

ASCX, ASPX - Файл с расширением ASCX используется для веб-управления пользователями ASP.NET, и расшифровывается как расширение активного серверного управления. По сути, файлы ASCX позволяют легко использовать один и тот же код на нескольких веб-страницах ASP.NET, экономя время и энергию при создании веб-сайта.
	Например, несколько файлов ASPX на веб-сайте могут ссылаться на один файл ASCX, который содержит код для меню навигации сайта. Вместо того чтобы писать один и тот же код на каждой странице веб-сайта, которой требуется меню, каждая страница может просто указывать на файл ASCX, что значительно упрощает управление и обновление меню на каждой странице.

Middleware (промежуточное или связующее программное обеспечение) — это фрагмент кода в конвейере приложения, используемый для обработки запросов и ответов. Например, у нас может быть middleware-компонент для аутентификации пользователя, middleware-компонент для обработки ошибок и еще один middleware-компонент для обслуживания статических файлов, таких как файлы JavaScript, CSS, разного рода изображения и т.д.

HTTP - является технология «клиент-сервер», то есть предполагается существование:
    Потребителей (клиентов), которые инициируют соединение и посылают запрос;
    Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.
	HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. В 2006 году в Северной Америке доля HTTP-трафика превысила долю P2P-сетей и составила 46 %, из которых почти половина — это передача потокового видео и звука. HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV. 

Фреймворк (framework — остов, каркас, структура) — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта. Употребляется также слово «каркас», а некоторые авторы используют его в качестве основного, в том числе не базируясь вообще на англоязычном аналоге. Можно также говорить о каркасном подходе как о подходе к построению программ, где любая конфигурация программы строится из двух частей: 
	Постоянная часть — каркас, не меняющийся от конфигурации к конфигурации и несущий в себе гнёзда, в которых размещается вторая, переменная часть;
    Сменные модули (или точки расширения).

Immutable Types - означает что данные хранящиеся в переменной немогут быть изменены. При этом значение преременной может быть изменено - путем отказа от старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые создаются вновь, в новой области памяти. Приер таких переменыых, String, DateTime.

StringBuilder - находится в пространстве имен System.Text. Этот класс представляет динамическую строку. Хотя класс System.String предоставляет нам широкую функциональность по работе со строками, все таки он имеет свои недостатки. Прежде всего, объект String представляет собой неизменяемую строку. Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места. Удаление первого символа - не самая затратная операция. Однако когда подобных операций множество, а объем текста, для которого надо выполнить данные операции, также не самый маленький, то издержки при потере производительности становятся более существенными. Чтобы выйти из этой ситуации во фреймворк .NET был добавлен новый класс StringBuilder. Этот класс представляет динамическую строку. При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке.

RPC(Remote Procedure Call) - Удалённый вызов процедур, реже Вызов удалённых процедур  — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (на удалённых компьютерах, либо в независимой сторонней системе на том же устройстве). Обычно реализация RPC-технологии включает в себя два компонента: сетевой протокол для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для необъектных RPC). Различные реализации RPC имеют очень отличающуюся друг от друга архитектуру и разнятся в своих возможностях: одни реализуют архитектуру SOA, другие — CORBA или DCOM. На транспортном уровне RPC используют в основном протоколы TCP и UDP, однако, некоторые построены на основе HTTP (что нарушает архитектуру ISO/OSI, так как HTTP — изначально не транспортный протокол)

gRPC - представляет фреймворк, который использует протокол RPC (Remote Procedure Call) для обмена сообщениями между клиентом и сервером. Цель фреймворка состоит в том, чтобы обеспечить высокую производительность в тех условиях, где это особенно критично, например, при интенсивном обмене информацией в режиме реального времени. gRPC не является частью ASP.NET Core или .NET, более того gRPC представляет технологию, которая не привязана к конкретному языку. Но тем не менее мы можем использовать gRPC в связке с ASP.NET Core для создания приложений.

Анонимные типы - позволяют создать объект с некоторым набором свойств без определения класса. Определяется с помощью ключевого слова var и инициализатора объектов. Следует учитывать, что свойства анонимного объекта доступны для установки только в инициализаторе. Вне инициализатора присвоить им значение мы не можем. Пример:
	var v = new { Amount = 108, Message = "Hello" };

readonly и const разница? - Значения констант должны быть установлены к моменту компиляции. Значения полей для чтения можно устанавливать при выполнении программы в конструкторе

Локальная функция - представляют собой частные методы типа, вложенные в другой элемент. Они могут вызываться только из того элемента, в который вложены. Элементы, в которых можно их вложить: Методы, в частности методы итератора и асинхронные методы, Конструкторы, Методы доступа свойств, Методы доступа событий, Анонимные методы, Лямбда-выражения, Методы завершения, Другие локальные функции

GUI (Графический интерфейс пользователя) - графический пользовательский интерфейс. Тоже самое что и API только для людей

Boxing\Unboxing -  Упаковка (boxing) позволяет преобразовать размерный тип в ссылочный. При упаковке объекта размерного типа происходят следующие действия:
    1 Выделяется память в управляемой куче.
    2 Совершается копирование полей размерного типа в память, которая была выделена в куче.
    3 Возвращается адрес объекта.

	Распаковкой (unboxing) это процесс извлечении из object значения переменной. Распаковка не является точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем упаковка, и состоит только в получении ссылки. Однако вслед за распаковкой обычно выполняется копирование полей. Распаковкой и копирование являются противоположностью упаковки.
	
	object ob1; 
	int x = 12; 
	ob1 = x; //происходит упаковка значения переменнойx в ob1
	int a = (int)ob1; // происходит распаковка, используется явное преобразование типов. 
	C# любой класс(тип) наследует базовый тип object. Это значит, что любой тип можно преобразовать к типу object и обратно.

Generic<T>(Обобщения\Дженерик) - методы, который принимает аргумент любого типа, что-то делает с ним (например выводит в консоль его через ToString()) и возвращает этот же самый аргумент того же типа(это особый способ описание используемых типов, который сможет использовать в своей работе компилятор кода для обеспечения типобезопасности)

Generic handler (Универсальный обработчик) - В соответствии с MSDN, generic хендлер это хендлер по умолчанию, который имеет директиву @webhandler и расширение .ashx. Создаете вы такой хендлер путем создания .ashx файла. Собственно говоря, в ASP.NET есть стандартный хендлер, который обрабатывет .ashx страницы и больше ничего конфигурировать вам не надо. Можно, использовать для создания миниатюр изображений, когда все запросы будут посылаться .ashx файлу, передавая также размеры миниатюры, а он динамически будет формировать графические файлы заданных размеров

Legacy-система — в переводе с английского «наследство», и наследственность эта тяжелая. Почти всем доводилось, придя в проект, получить код десятилетней давности, написанный кем-то другим. Это и есть унаследованный код — то есть код исторический, который часто бывает ужасен настолько, что оказывается вообще непонятно, как с ним работать. И если нам достается legacy-система, то мы, кроме старого кода, также имеем: устаревшие технологии, неоднородную архитектуру, недостаток или даже полное отсутствие документации.

Thread - это отдельный поток в котором вы хотите что-то выполнять параллельно от других потоков. (например чтобы не зависал интерфейс, вы запускаете вашу задачу в отдельном потоке)(например вы хотите задействовать все ядра процессора и запускаете несколько задач в нескольких параллельных потоках)

Task - это обертка над Thread которая позволяет переиспользовать созданные потоки (Пул потоков). Переиспользовать потому-что создавать каждый раз Thread это очень долго и дорого.
	Task-и так же предоставляют дополнительный фишки как:
	- асинхронная модель (async/await),
	- учёт количества ядер процессора,
	- учёт простоя во время системных вызовов (сеть, файловая система, БД и т.п.)

Acync / Await -  позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и при этом более экономно использовать потоки. Асинхронные методы выполняются в отдельных потоках. В качестве возвращаемого типа используется один из следующих:
    void
    Task
    Task<T>
    ValueTask<T>
	1)Начинает синхронно выполняться async-метод. Если этот метод заканчивается до первого await, результат доставляется синхронно, и из метода возвращается уже закончившийся, завершённый Task.
	2)Если в процессе выполнения встретился await, система проверяет, отработало ли уже задание, на которое вызывался await. Если это задание отработало, то подставляется его результат, и синхронное выполнение продолжается дальше.
	3)Если задание, на которое происходит await, ещё не отработало, в этот момент из метода возвращается незавершённый Task. В этой точке внешний код получает управление и продолжает выполняться. Например, этот код может записать Task в переменную и продолжать заниматься своими делами. Или он может выполнить await на полученный Task, и поскольку этот Task ещё не завершён, внешний код в этот момент аналогично отдаст управление ещё более внешнему коду, и. т. д.
	4)Когда Task, на который происходит await, завершится (произведя результат или исключение), код после await возобновит свою работу.
	
Interlocked - представляет собой набор простых атомарных операций. Это, пожалуй, самый легковесный способ синхронизации потоков. Атомарной называется операция в момент выполнения которой не может ничего произойти. В .NET Interlocked представлен одноименным статическим классом с рядом методов, каждый из которых реализует одну атомарную операцию
	
Monitor - предоставляет механизм для синхронизации доступа к объектам.
	Наряду с оператором lock для синхронизации потоков мы можем использовать мониторы, представленные классом System.Threading.Monitor. Для управления синхронизацией этот класс предоставляет следующите методы::
    void Enter(object obj): получает в экслюзивное владение объект, передаваемый в качестве параметра.
    void Enter(object obj, bool acquiredLock): дополнительно принимает второй параметра - логическое значение, которое указывает, получено ли владение над объектом из первого параметра
    void Exit(object obj): освобождает ранее захваченный объект
    bool IsEntered(object obj): возвращает true, если монитор захватил объект obj
    void Pulse (object obj): уведомляет поток из очереди ожидания, что текущий поток освободил объект obj
    void PulseAll(object obj): уведомляет все потоки из очереди ожидания, что текущий поток освободил объект obj. После чего один из потоков из очереди ожидания захватывает объект obj.
    bool TryEnter (object obj): пытается захватить объект obj. Если владение над объектом успешно получено, то возвращается значение true
    bool Wait (object obj): освобождает блокировку объекта и переводит поток в очередь ожидания объекта. Следующий поток в очереди готовности объекта блокирует данный объект. А все потоки, которые вызвали метод Wait, остаются в очереди ожидания, пока не получат сигнала от метода Monitor.Pulse или Monitor.PulseAll, посланного владельцем блокировки.

Lock - инкапсулирует в себе синтаксис использования мониторов. С помощью Lock осуществляется блокировка одновременного выполнения определенных участков кода несколькими потоками. Инкапсулирует в себе синтаксис мониторов.

Semaphore - Используйте класс Semaphore для управления доступом к пулу ресурсов. Потоки входят в семафор, вызывая метод WaitOne, который наследуется от класса WaitHandle, и освобождают семафор, вызывая метод Release. Количество на семафоре уменьшается каждый раз, когда поток входит в семафор, и увеличивается, когда поток освобождает семафор. Когда счетчик равен нулю, последующие запросы блокируются до тех пор, пока другие потоки не освободят семафор. Когда все потоки освободили семафор, счетчик имеет максимальное значение, указанное при создании семафора. Поток может входить в семафор несколько раз..Класс Semaphore не применяет идентификатор потока к WaitOne или Release .. ответственность программистов за то, чтобы не испортить.Семафоры бывают двух типов: локальные семафоры и именованные системные семафоры. Если вы создаете объект семафора, используя конструктор, который принимает имя, он связан с семафором операционной системы с этим именем.Именованные системные семафоры видны во всей операционной системе и могут использоваться для синхронизации действий процессов. Локальный семафор существует только внутри вашего процесса. Он может использоваться любым потоком в вашем процессе, который имеет ссылку на локальный объект Semaphore. Каждый объект семафора является отдельным локальным семафором

Mutex (mutual exclusion) - взаимное исключение или мьютекс является одним из классов в .NET Framework, позволяющих обеспечить синхронизацию среди множества процессов. Он очень похож на класс Monitor тем, что тоже допускает наличие только одного владельца. Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода. В конструкторе класса Mutex указывается, должен ли мьютексом изначально владеть вызывающий поток, и его имя. Кроме того, конструктор позволяет получить информацию о том, существует ли уже такой класс.
	Мьютекс представляет собой взаимно исключающий синхронизирующий объект. Это означает, что он может быть получен потоком только по очереди. Мьютекс предназначен для тех ситуаций, в которых общий ресурс может быть одновременно использован только в одном потоке. Допустим, что системный журнал совместно используется в нескольких процессах, но только в одном из них данные могут записываться в файл этого журнала в любой момент времени. Для синхронизации процессов в данной ситуации идеально подходит мьютекс.
	
ThreadPool - Предоставляет пул потоков, который можно использовать для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров. Он решает несколько задач:
    с одной стороны он абстрагирует создание потока: мы этим заниматься не должны
    создав когда-то поток, он исполняет на нём совершенно разные задачи. Вам же не важно, на каком из них исполняться? Главное чтобы был
    а потому мы более не тратим время на создание потока ОС: мы работаем на уже созданных
    потому нагружая ThreadPool своими делегатами мы можем равномерно загрузить ядра CPU работой
    либо ограничивает пропускную способность либо наоборот: даёт возможность работать на все 100% от всех процессорных ядер.
	
EF (Entity Framework) - ORM (object-relational mapper) или инструмент, связывающий объектную модель, с которой мы работаем в коде (C# классы, коллекции, свойства) с реляционной моделью базы данных (таблица, столбец, запись, связи...) Один из плюсов- не нужно заморачиваться с написание SQL запросов и в основнов все пишется на LINQ, минус - не все запросы получаюся оптимизированными, могут проходить слишком медленно и тогда приходится их писать на SQL.

Конвеер обработки (Pipelin \ HTTP pipelin) - программное обеспечение, задача которого состоит в получении запроса, его обработке и отклике. Состоит оно из конвеера обработчиков Middleware (таких как Logger, Authentication, Cors, Mvc и.т.д.) Каждый компонент по очередно обрабатывет запрос по своему, после чего определяет нужно ли передать запрос следующему компоненту в конвейера или прервать его. Прерывание запроса также важно, т.к. чем раньеш происходит прерываие тем меньше будет нагрузки на остальные компоненты, соответсвенно и меньше нагрузка на сервер. Так же могут выполнять работу как до, так и после вызова следующего компонента в конвейере. В ASP.NET Core для подключенея компонентов в основном используюется метод Configure в классе Startup, а загружаются через nuget package manager. Но могут быть и кастомными. Возможность комбинировать, удалаять и добалять нужные компаненты Middleware делает конвеер обработки очень удобным инструментом для обработки запросов.


JIT (Just in time) - Для выполнения какого-либо метода, его IL-код должен быть преоразован в машинные команды. Этим и занимается JIT-компилятор.
	Возможности повышения проиводительности упр. кода по сравнению с неуправляемым:
    JIT-компилятор может определить на каком процессоре выполянется приложение и использовать его специальные команды для повышения эффективности
    JIT-компилятор может определить, что некоторое условие на том компьютере, на котором он выполняется, всегда оказывается ложным
    CLR может профилировать выполняемую программу и перекомпилировать IL в машинный код в процессе выполнения. Перекомпилированный код реорганизуется для сокращения ошибочного прогнозирования переходов на основании наблюдаемых закономерностей выполнения

DRY (Don't repeat yourself) - Не повторяй себя, это принцип разработки программного обеспечения, направленный на сокращение повторения паттернов программного обеспечения, заменяя их абстракциями или используя нормализацию данных, чтобы избежать избыточности.

YAGNI (You aren't gonna need it - Вам это не понадобится) — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности

KISS (Keep it simple, stupid Делай проще, тупица) - принцип проектирования, принятый в ВМС США в 1960 утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности. Фраза ассоциировалась с авиаконструктором Кларенсом Джонсоном (1910—1990). В 1970-х гг. широко использовался термин «KISS-принцип». Вариации на фразу включают «Keep it Simple, Silly», «keep it short and simple», «keep it simple and straightforward» и «keep it small and simple». 

Агрегация - тип отношений, в которых дочерняя структура может существовать независимо от родительской. Пример: Person (родительский класс) и Student (дочерний класс). Если Person будет удалён, Student всё равно продолжит существовать

Композиция - тип отношений, в которых дочерняя структура не может существовать отдельно от родительской. Пример: House (родительский класс) и Room (дочерний класс). Room не существует отдельно от House

Dapper - представляет собой технологию сопоставления (маппинга) результатов sql-запросов с классами c#. В этом плане Dapper немного похож на Entity Framework. В то же время за счет своей легковесности Dapper обеспечивает большую производительность и быстрее позволяет выполнять запросы, нежели Entity Framework.

Unmanaged code (Неуправляемый код) - Код, который создан без следования соглашениям и требованиям среды выполнения. Неуправляемый код выполняется в среде CLR с минимальными сервисами (например, для них отсутствует сборщик мусора, ограничены возможности по отладке и т.д.)

Managed code (Управляемый код) - Код, который запускается под "contract of cooperation" в среде выполнения. Управляемый код должен содержать метаданные, необходимые среде выполнения для того, чтобы обеспечить работу сервисов, таких, как управление памятью, межъязыковая интеграция, проверка доступа кода и автоматическое управление жизненным циклом объектов. Весь код, представленный в виде промежуточного языка, выполняется как управляемый код. Cм. также Microsoft intermediate language (MSIL)

Partialview (частичное представление) - термина используется при разработке приложения MVC, где файлы разметки называются представлениями или приложением Razor Pages, где файлы разметки называются страницами. Этот раздел обычно относится к представлениям MVC и Razor страницам Pages в качестве файлов разметки. Частичные представления позволяют эффективно выполнять следующие задачи:
    Разбить большие файлы разметки на мелкие компоненты.
	Сократить дублирование элементов разметки в разных файлах разметки.
	Не используйте частичное представление там, где требуется сложная логика визуализации или выполнение кода для визуализации разметки. В этой ситуации лучше применить компонент представления.

Enum - базовый класс для перечислений. Набор именованных констант, базовый тип которого является любым целочисленным типом. Если базовый тип явно не объявлен, используется Int32.

Decimal - Тип значения представляет десятичные числа в диапазоне от плюс 79,228,162,514,264,337,593,543,950,335 до -79,228,162,514,264,337,593,543,950,335. Значение по умолчанию Decimal равно 0. Подходит для финансовых вычислений, требующих большого числа значащих цифр целой и дробной части и отсутствия ошибок округления. Не устраняет необходимость округления. Но он сводит к минимуму ошибки, возникающие из-за округления.

Dynamic - является статическим типом, но объект типа dynamic обходит проверку статического типа. В большинстве случаев он работает как тип object. Во время компиляции предполагается, что элемент, типизированный как dynamic, поддерживает любые операции. Это значит, что вам не придется задумываться о том, получает ли объект значение из API COM, из динамического языка, такого как IronPython, из модели DOM HTML, из отражения или из другой части программы. При этом если код недопустимый, ошибки перехватываются во время выполнения.

Finalize (Деструктор) - Object.Finalize - Предусматривает завершение объекта, если неуправляемые ресурсы не освобождены методом Dispose. Основным типом неуправляемых ресурсов являются объекты, заключающие ресурсы операционной системы, такие как файлы, окна, сетевые подключения и подключения к базам данным. Хотя сборщик мусора может отслеживать время жизни управляемого объекта, инкапсулирующего неуправляемые ресурсы, он не имеет сведений о том, как освобождать такие ресурсы.

Fluent API - Если мы используем подход Code First, то классы моделей сопоставляются с таблицами с помощью ряда правил в Entity Framework. Но иногда необходимо изменить и переопределить логику этих правил. Для этого используется Fluent API и аннотации данных. Fluent API по большому счету представляет набор методов, которые определяются сопоставление между классами и их свойствами и таблицами и их столбцами. Как правило, функционал Fluent API задействуется при переопределении метода OnModelCreating

Указатели - позволяют получить доступ к определенной ячейке памяти и произвести определенные манипуляции со значением, хранящимся в этой ячейке. Фактический это теже ссылки указывающие на определенные учаски памяти. Код, применяющий указатели называют небезопасным (unsafe) кодом т.к. при работе с ним все действия по использованию памяти, в том числе по ее очистке, ложится целиком на нас, а не на среду CLR. 
	unsafe
	{
		int* x; // определение указателя
		int y = 10; // определяем переменную
		x = &y; // указатель x теперь указывает на адрес переменной y
		Console.WriteLine(*x); // 10
	}
	
Хэширование - преобразование данных любой длины в данные заданной длины

Симетричный обход дерева - рекусивный обход элементов дерева когда мы сначала берем левый элемент, затем родителя, а после правый элемент, при этом если ключи выводятся по возростанию значит все прошло успешно

Обратный обход дерева - сначала выводим левого ребенка потом правого потом родителя, позволяет безопано удалить все элементы последовательно, т.к. сначала удаляются узлы которые ни на кого не ссылаются, а значит никто не будет пропущен

Прямой обход дерева - сначала выводися родитель, потом левый ребенок, потом правый, удобен при копировании, т.к. мы проходимся в порядке добавления элиментов свеху вниз

Authentication - Процесс идентификации пользователя, проверка его удостоверения личности в определенной системе авторизации. Аутентификация не отвечает на вопрос, имеет ли пользователь доступ к данным ресурсам, а только проверяет, тот ли он, за кого себя выдает.
    Cм. также principal

Authorization - Процесс, который отвечает на вопрос, разрешено ли данному пользователю выполнение запрошенной операции. Авторизация происходит после аутентификации и использует идентификатор пользователя, чтобы определить, доступ к каким ресурсам ему разрешен.

Localization - Локализация Процесс настройки или перевода отдельных данных и ресурсов, необходимых для определенного географического региона или языка

Records - представляют новый ссылочный тип, который появился в C#9. Ключевая особенность records состоит в том, что они могут представлять неизменяемый (immutable) тип, который по умолчанию обладает рядом дополнительных возможностей по сравнению с классами и структурами. Зачем нам нужны неизменяемые типы? Такие типы более безопасны в тех ситуациях, когда нам надо гарантировать, что данные объекта не будут изменяться.

Граф – абстрактная структура данных, которая состоит из набора вершин и соединений между ними – ребер. При этом каждое ребро может иметь вес.

Сложность алгоритма - асимптотическа сложность О от n при n стремящейся к бесконечноти. Фактический показывает сколько времени будет затрачено в данном алгоритме при увеличении n.
	О(1) вообще не зависит от n
	O(n) например сумма n элементов. Чем больше элементов тем дольше идет сложение.
	О(n log n) 
	О(n^2) например поиск дублирующихся фалов
	О(2^n)
	О(n!) один из самых тяжелых случаев например когда происхо подбор пароля и чем больше символов в пароле тем время подбора больше
	
Конкурентное программирование в C# - позволяет эффективно использовать ресурсы компьютера и повысить производительность приложений. Для этого используются многопоточность и асинхронность, которые реализуются с помощью классов Thread, Task и Task<T>. При разработке многопоточных приложений важно обеспечить потокобезопасность общих ресурсов и использовать механизмы синхронизации, такие как мьютексы и семафоры.

Утиная типизация - Если что-то выглядит как уточка и говорит как уточка, это переменная типа «уточка» Во многих языках программирования есть такое правило: если нужно сразу обработать несколько объектов, то они должны быть одного типа — это позволит выполнять над ними одинаковые действия и получать предсказуемый результат.
JavaScript для новичков: чем опасны нестрогие типы данных. Но в некоторых языках бывает так, что объекты или переменные принадлежат к разным типам или классам, но их всё равно можно смешивать и обрабатывать так, будто они одного вида. У программистов это называется утиной типизацией.

Transaction outbox pattern\Application events - обеспечивает сохранение сообщений в хранилище данных (как правило, в таблице outbox в базе данных), прежде чем они будут в конечном итоге переданы в брокер сообщений. Если бизнес-объект и соответствующие сообщения сохраняются в рамках одной транзакции базы данных, это гарантирует, что данные не будут потеряны. Либо будет зафиксировано все, либо при возникновении ошибки произойдет полный откат.

Какой патерн реализует DBContext из EntityFameWork - UnitOfWork сначала собирает все изменения а потом из разом сохраняет.

2pc (Two-phase commit protocol) - 

Guid (Глобально уникальные идентификаторы) - это 128-битные значения, используемые в C# для уникальной идентификации объектов, сущностей или ресурсов в различных системах и приложениях. Эти идентификаторы также называются UUID (Универсально уникальные идентификаторы) в некоторых других языках программирования

Closure(Замыкание) - представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.
	Технически замыкание включает три компонента:
    Внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение
    Переменные и параметры (лексическое окружение), которые определены во внешней функции
    Вложенная функция, которая использует переменные и параметры внешней функции

Finalize и Dispose - Dispose обеспечивает явный контроль над ресурсами, используемыми объектом, а Finalize - неявный, используемый сборщиком мусора

System.Array.CopyTo и Clone() - Первая операция осуществляет глубокое копирование массива, а вторая – поверхностное. Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами. Копирования объектов, на которые ссылаются ссылочные типы не происходит. Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array. Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются

throw ex и throw - 
    throw повторно выбрасывает исключение (re-throw), которое было обнаружено, и сохраняет трассировку стека (путь к источнику исключения)
    throw ex генерирует одно и то же исключение, но сбрасывает трассировку стека на метод, где делается throw ex

GC.KeepAlive(object obj) - Ссылается на указанный объект, что делает его непригодным для сборки мусора с момента начала текущей процедуры до момента вызова этого метода.

Tuple(кортеж) - обеспечивает краткий синтаксис для группировки нескольких элементов данных в упрощенную структуру.
	(string, int, double) person = ("Tom", 25, 81.23);
	Console.WriteLine(person.Item1);
	Console.WriteLine(person.Item2);
	(int, int) tuple = (5, 10);
	Console.WriteLine(tuple.count);
	Console.WriteLine(tuple.sum);
	
Graph - набор узлов, называемых вершинами, и соединений между ними, называемых ребрами. В аналогии, можно представить город как граф, где перекрестки являются вершинами, а дороги между ними — ребрами.
https://ci-sharp.ru/algoritmy-i-struktury-dannyh/struktury-dannyh/struktura-dannykh-graf-v-c/?ysclid=lyyi66hazf262838834

GRASP (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей. GRASP шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам. Существует девять GRAPS шаблонов, изначально описанных в книге  Крейга Лармана «Применение UML и шаблонов проектирования». В отличие от классических читателю паттернов из Банды Четырех, GRAPS паттерны не имеют выраженной структуры, четкой области применения и конкретной решаемой проблемы, а лишь представляют собой обобщенные подходы/рекомендации/принципы, используемые при проектировании дизайна системы.

	GRASP состоит из 5 основных и 4 дополнительных шаблонов.
	Основные шаблоны:
		Information Expert
		Creator
		Controller
		Low Coupling
		High Cohesion
	
	Дополнительные шаблоны:
		Pure Fabrication
		Indirection
		Polymorphism
		Protected Variations
		
Information Expert (Информационный эксперт) - Шаблон определяет базовый принцип распределения ответственности. Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту. Этот шаблон — самый очевидный и важный из девяти. Если его не учесть — получится "спагетти-код", в котором трудно разобраться. Применение шаблона информационный эксперт повышает связность модулей и не противоречит свойству инкапсуляции. К примеру класс Customer содержит ссылки на все заказы клиентов, следовательно логично разместить тут метод для подсчета общей стоимости заказов:

Creator (Создатель) — суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с абстрактной фабрикой. По сути шаблон проектирования Абстрактная фабрика (создание объектов концентрируется в отдельном классе) это альтернатива создателя. Но есть ряд моментов, которые должны выполняться, когда мы наделяем объект ответственностью создателя:
    Создатель содержит или агрегирует создаваемые объекты
    Создатель использует создаваемые объекты 
    Создатель знает, как проинициализировать создаваемый объект 
    Создатель записывает создаваемые объекты
    Создатель имеет данные инициализации для A
		

ML.NET (Machine Learning/Машинное обучение) - 
https://habr.com/ru/companies/jugru/articles/495208/
https://blog.jetbrains.com/dotnet/2023/02/01/getting-started-with-ml-dotnet-machine-learning/
https://rubikscode.net/2022/08/29/machine-learning-with-ml-net-introduction/

11111 - 11111